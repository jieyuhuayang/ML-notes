# 一、机器学习的一些概念
1. supervised learning（有监督学习）：  
给定数据集有**标记信息（label）**，已知输出结果的形式（分类、回归等）。  <br/><br/>
2. unsupervised learning（无监督学习）：
给定数据集没有标记信息（label），也就**不知道输出结果的形式**（例如聚类）。<br/><br/>
3. generalization（泛化能力）：
机器学习算法对新鲜样本的适应能力。<br/><br/>
4. overfitting（过拟合）or high variance（高方差）：
学习器把训练样本“学习得太好了”，把训练样本自身的一些特点当成了所有潜在样本都会具有的一般性质，导致泛化性能下降。  
    - 解决办法：  
    ①减少特征的数量：手动选择特征；使用算法去进行模型选择。  
    ②Regularization 正则化。<br/><br/>
5. underfitting（欠拟合）or high bias（高偏差）：与过拟合相对应，指对训练样本的一般性质尚未学好。
    - 解决办法：通常是因为函数太简单或者特征太少导致，所以可以通过增加函数复杂性或增加特征改善。<br/><br/>
6. cross validation（交叉验证）：一种对学习器学习效果的的评估方法。  
    - 把数据集D**分层采样**（保持数据分布一致性）划分为k个大小相似的互斥子集，每次采用k-1个子集进行训练，余下那个子集作为测试集；这样可以进行k次训练和测试，最后返回k次测试结果的均值。
    - 也有说法是划分成训练集、验证集、测试集。通过西瓜书第28页，我的理解是，如果是在评估模型实际使用时的泛化能力，这个时候模型的参数已经确定了，自然不需要验证集，训练完后直接在测试集上得出测试结果即可；如果你是在模型评估与选择时，那么你需要验证集来评估学习器的效果，从而确定最佳的参数，这个时候你是需要验证集的。
> 我们用测试集的判别效果来估计模型在实际使用时的泛化能力，而把训练数据分成训练集和验证集，基于验证集上的性能进行模型选择和调参。

# 二、线性回归的原理
线性回归实质上是想构造一个线性的模型，能够尽可能准确地预测输出。  
线性模型长这个样子：
![我是图片注释](http://latex.codecogs.com/gif.latex?f%28x_i%20%29%3D%5Comega%20%5E%7BT%7Dx_%7Bi%7D&plus;b  ''我是图片title'')
那么怎么确定ω和b呢？首先我们需要一个性能度量，表明什么时候ω和b是合适的值，这里我们采用square loss（均方误差）作为性能度量，通过让square loss最小化来求得ω和b。  
这种方法也叫least square method（最小二乘法），从几何意义上说，它是想找到一条直线使得所有样本到直线上的欧氏距离之和最小  
# 三、线性回归损失函数、代价函数、目标函数 
1. Loss Function（损失函数）是定义在单个样本上的，计算的是一个样本的误差。
2. Cost Function（代价函数）是定义在整个训练集上的，是所有样本误差的平均，也就是损失函数的平均。
3. Object Function（目标函数）定义为：最终需要优化的函数。等于经验风险+结构风险（也就是Cost Function + 正则化项）。  
# 四、优化方法(梯度下降法、牛顿法、拟牛顿法等) 
前面已经说到，大部分的机器学习算法的本质都是建立优化模型，通过最优化方法对目标函数（或损失函数）进行优化，从而训练出最好的模型。常见的最优化方法有梯度下降法、牛顿法和拟牛顿法、共轭梯度法等等。
1. 梯度下降法（Gradient Descent）   
梯度下降法的优化思想是用当前位置负梯度方向作为搜索方向，因为该方向为当前位置的最快下降方向，Gradient Descent越接近目标值，步长越小，收敛速度越慢。  <br/><br/>
梯度下降法实现简单，当目标函数是凸函数时，梯度下降法的解是全局解。一般情况下，其解不保证是全局最优解，梯度下降法的速度也未必是最快的。  <br/><br/>
2. 牛顿法（Newton's method）  
在数值分析里我们学过，牛顿法是求解函数值为0时的自变量取值的方法。  <br/><br/>
利用牛顿法求解目标函数的最小值其实是转化成求使目标函数的一阶导为0的参数值。这一转换的理论依据是，函数的极值点处的一阶导数为0.  <br/><br/>  
其迭代过程是在当前位置x0求该函数的切线，该切线和x轴的交点x1，作为新的x0,重复这个过程，直到交点和函数的零点重合。此时的参数值就是使得目标函数取得极值的参数值。<br/><br/>
其迭代过程如下：  ![我是图片注释](https://images2018.cnblogs.com/blog/801049/201805/801049-20180508190534002-1616058786.png  ''我是图片title'')
如果用牛顿法求解f(x)的极值呢？很简单，牛顿迭代方程稍微做下改动即可： 
![我是图片注释](http://latex.codecogs.com/gif.latex?x%20%3D%20x%20-%20%5Cfrac%7Bf%27%28x%29%7D%7Bf%27%27%28x%29%7D  ''我是图片title'') <br/><br/> 
对于高维函数，用牛顿法求极值也是这个形式，只不过这里的f′′(x)和f′(x)都变成了矩阵和向量。而且你也可以想到，高维函数二阶导有多个，写成矩阵的形式就是这样  
![我是图片注释](http://latex.codecogs.com/gif.latex?H%28x%29%20%3D%20%5B%5Cfrac%7B%5Cpartial%5E2f%7D%7B%5Cpartial%7Bx_i%7D%5Cpartial%7Bx_j%7D%7D%5D_%7Bn%5Ctimes%20n%7D%20%3D%20%5Cbegin%7Bbmatrix%7D%20f_%7B11%7D%20%26%20%5Ccdots%20%26%20f_%7B1n%7D%20%5C%5C%20%5Cvdots%20%26%20%5Cddots%20%26%20%5Cvdots%20%5C%5C%20f_%7Bn1%7D%20%26%20%5Ccdots%20%26%20f_%7Bnn%7D%20%5C%5C%20%5Cend%7Bbmatrix%7D  ''我是图片title'')<br/><br/>  
所以有了海赛矩阵，牛顿迭代法就有如下形式：   
![我是图片注释](http://latex.codecogs.com/gif.latex?X%20%3A%3D%20X%20-%20H%5E%7B-1%7D%28X%29%5Cnabla%20f%28X%29%2C%20X%20%3D%20x_1%2Cx_2%2C...%2Cx_n  ''我是图片title'') <br/><br/> 
对于H(x)H(x)有如下结论：  
    - 如果H(x)是正定矩阵，则临界点M处是一个局部的极小值。  
    - 如果H(x)是负定矩阵，则临界点M处是一个局部的极大值。  
    - 如果H(x)是不定矩阵，则临界点M处不是极值。<br/><br/>    
3. 拟牛顿法（Quasi-Newton method）  
牛顿法虽然速度很快，海森矩阵的逆计算复杂，代价比较大，因此有了拟牛顿法。<br/><br/>
**拟牛顿法的本质思想是改善牛顿法每次需要求解复杂的Hessian矩阵的逆矩阵的缺陷，它使用正定矩阵来近似Hessian矩阵的逆，从而简化了运算的复杂度。**拟牛顿法和最速下降法一样只要求每一步迭代时知道目标函数的梯度。通过测量梯度的变化，构造一个目标函数的模型使之足以产生超线性收敛性。这类方法大大优于最速下降法，尤其对于困难的问题。另外，因为拟牛顿法不需要二阶导数的信息，所以有时比牛顿法更为有效。
详情参见 [牛顿法与拟牛顿法学习笔记](https://blog.csdn.net/itplus/article/details/21896619)   
# 五、线性回归的评估指标  
1. 均方误差 mean squared error（MSE）  
![](https://img-blog.csdnimg.cn/20181219172928787.png)  
2. 均方根误差 root mean squared error（RMSE）  
MSE有一个问题是因为做了平方，所以量纲可能会有问题，对其进行开根号得到RMSE，它和MSE的区别仅在于对量纲是否敏感。![](https://img-blog.csdnimg.cn/20181219172951560.png)  
3. 线性回归最好的评估指标——R Squared  
但是在回归中预测不同的实际场景，比如一个预测股市，一个预测房价，它们两个的量纲是不一样的，比较MSE或者RMSE区分不出谁好谁坏。所以将预测结果转换为准确度，结果都在[0, 1]之间，针对不同问题的预测准确度，可以比较并来判断此模型更适合预测哪个问题。  
![](https://images2018.cnblogs.com/blog/1036486/201803/1036486-20180302155309676-1020415548.png)  
![](https://images2018.cnblogs.com/blog/1036486/201803/1036486-20180302155715312-1898824494.png)  
上面那个分数中的分母称为**基准模型（Baseline Model）**，适用于所有的线型回归算法，它不考虑x的取值，只是很生硬的将所有的预测样本的预测结果都认为是样本y的均值。  
- R^2越大越好，当自己的预测模型不犯任何错误时：R^2 = 1
- 如果R^2 < 0，说明学习到的模型还不如基准模型。  
>注：如果R^2 < 0很可能数据不存在任何线性关系，用线性回归之前可以先对数据进行相关性检验，或者先对数据的残差分布进行判定.  
  
# 六、sklearn参数详解  
```python
sklearn.linear_model.LinearRegression(fit_intercept=True, normalize=False, copy_X=True, n_jobs=1)
```  
参数
- fit_intercept：布尔型，默认为true。如果该变量为false，则表明输入的数据已经进行了中心化，在下面的过程里不进行中心化处理；否则，对输入的训练数据进行中心化处理。  
- normalize：布尔型，默认为false。是否对数据进行标准化缩放。
- copy_X：布尔型，默认为true。如果选择false，则直接对原数据进行覆盖。（即经过中心化，标准化后，是否把新数据覆盖到原数据上）
- n_jobs：整型， 默认为1  说明：计算时设置的任务个数(number of jobs)。如果选择-1则代表使用所有的CPU。这一参数的对于目标个>1（n_targets>1）且足够大规模的问题有加速作用。  
  

